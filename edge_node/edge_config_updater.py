"""
Edge Node Configuration Updater

This script runs on edge nodes and periodically fetches configuration
from the control plane, then updates Nginx/OpenResty configuration.
"""
import asyncio
import json
import logging
import subprocess
import os
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime
import shlex
import aiofiles
import psutil

import httpx
import yaml
from jinja2 import Template


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


LOG_FORMAT_CONF = """
# Generated by Edge Config Updater
log_format cdn_json_log escape=json '{'
    '"timestamp": "$time_iso8601",'
    '"domain": "$host",'
    '"client_ip": "$remote_addr",'
    '"method": "$request_method",'
    '"path": "$request_uri",'
    '"status": $status,'
    '"bytes_sent": $body_bytes_sent,'
    '"referer": "$http_referer",'
    '"user_agent": "$http_user_agent",'
    '"request_time": $request_time,'
    '"cache_status": "$upstream_cache_status"'
'}';
"""

NGINX_TEMPLATE = Template("""
# Generated by Edge Config Updater
# Version: {{ version|default('unknown') }}
# Generated at: {{ timestamp|default('') }}

{% for domain in domains %}
{% set safe_name = domain.name|replace('.', '_') %}
{% set backend_protocol = 'https' if domain.tls_settings.mode in ['full', 'strict'] else 'http' %}

# Domain: {{ domain.name }}

# Cache zone for this domain (http context)
proxy_cache_path /var/cache/nginx/{{ safe_name }} levels=1:2 keys_zone={{ safe_name }}:10m max_size=1g inactive=10m use_temp_path=off;

upstream {{ safe_name }}_backend {
    {% for origin in domain.origins %}
    server {{ origin.host }}:{{ origin.port if backend_protocol == 'http' else (443 if origin.port == 80 else origin.port) }} weight={{ origin.weight }} {% if origin.is_backup %}backup{% endif %};
    {% endfor %}
}

{# HTTPS server if TLS is enabled and certificate is available #}
{% if domain.tls_settings.enabled and domain.tls_certificate %}
server {
    listen 443 ssl http2;
    server_name {{ domain.name }};

    access_log /var/log/nginx/cdn_access.json.log cdn_json_log;

    ssl_certificate {{ domain.tls_certificate.cert_path }};
    ssl_certificate_key {{ domain.tls_certificate.key_path }};

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    {% if domain.tls_settings.hsts_enabled %}
    add_header Strict-Transport-Security "max-age={{ domain.tls_settings.hsts_max_age|default(31536000) }}{% if domain.tls_settings.hsts_include_subdomains %}; includeSubDomains{% endif %}" always;
    {% endif %}

    {% if domain.cache_rules %}
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ safe_name }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}

        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    {% endif %}

    location / {
        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ACME Challenge support (HTTP-01)
    location /.well-known/acme-challenge/ {
        # Proxy to control plane public endpoint (no auth required)
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
# HTTP server for ACME challenges (always present when TLS enabled)
server {
    listen 80;
    server_name {{ domain.name }};
    access_log /var/log/nginx/cdn_access.json.log cdn_json_log;
    
    # ACME Challenge support (HTTP-01)
    location /.well-known/acme-challenge/ {
        # Proxy to control plane public endpoint (no auth required)
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
{% if domain.tls_settings.force_https %}
    # Redirect all other HTTP traffic to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
{% else %}
    # Allow HTTP traffic (no redirect)
    location / {
        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
{% endif %}
}

{% else %}
# HTTP-only domain (TLS disabled or certificate unavailable)
server {
    listen 80;
    server_name {{ domain.name }};
    access_log /var/log/nginx/cdn_access.json.log cdn_json_log;

    {% if domain.cache_rules %}
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ safe_name }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}

        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    {% endif %}

    location / {
        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ACME Challenge support (HTTP-01)
    location /.well-known/acme-challenge/ {
        # Proxy to control plane public endpoint (no auth required)
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host $host;
    }
}
{% endif %}

{% endfor %}
""")


class LogShipper:
    """Reads Nginx JSON logs and ships them to the control plane"""
    
    def __init__(self, config: Dict[str, Any], api_key: str):
        self.config = config
        self.api_key = api_key
        self.node_id = config["edge_node"]["id"]
        self.control_plane_url = config["control_plane"]["url"].rstrip("/")
        self.log_file = Path("/var/log/nginx/cdn_access.json.log")
        self.batch_size = 100
        self.poll_interval = 1.0
        self.request_timeout = 10.0
    
    async def send_logs(self, logs: List[Dict[str, Any]]) -> bool:
        url = f"{self.control_plane_url}/internal/edge/logs"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }
        
        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.post(url, json=logs, headers=headers)
                response.raise_for_status()
                return True
        except Exception as e:
            logger.error("Failed to ship logs: %s", e)
            return False

    async def run(self):
        logger.info("Log Shipper started (file=%s)", self.log_file)
        
        while True:
            if not self.log_file.exists():
                await asyncio.sleep(5)
                continue
                
            try:
                # Open file and tail it
                async with aiofiles.open(self.log_file, mode='r') as f:
                    # Seek to end initially
                    await f.seek(0, 2)
                    
                    batch = []
                    last_send = datetime.now()
                    
                    while True:
                        line = await f.readline()
                        if line:
                            try:
                                log_entry = json.loads(line)
                                batch.append(log_entry)
                            except json.JSONDecodeError:
                                logger.warning("Invalid JSON in log line")
                                continue
                        else:
                            await asyncio.sleep(self.poll_interval)
                        
                        # Send if batch full or time elapsed (every 5 seconds)
                        now = datetime.now()
                        if len(batch) >= self.batch_size or (batch and (now - last_send).total_seconds() > 5):
                            if await self.send_logs(batch):
                                batch = []
                                last_send = now
                            else:
                                # Keep batch and retry next loop
                                await asyncio.sleep(2)
                                
            except Exception as e:
                logger.error("Error in log shipper loop: %s", e)
                await asyncio.sleep(5)


class EdgeConfigUpdater:
    """Edge node configuration updater"""

    def __init__(self, config_path: str = "config.yaml"):
        # Путь к конфигу можно переопределить через env,
        # относительный путь считаем от директории скрипта.
        config_path = os.getenv("EDGE_UPDATER_CONFIG", config_path)
        config_file = Path(config_path)
        if not config_file.is_absolute():
            config_file = Path(__file__).resolve().parent / config_file

        with open(config_file) as f:
            self.config = yaml.safe_load(f)

        self.node_id = self.config["edge_node"]["id"]
        self.control_plane_url = self.config["control_plane"]["url"].rstrip("/")
        self.api_key = self.config["control_plane"]["api_key"]
        self.current_version = 0

        self.nginx_config_path = Path(self.config["nginx"]["config_path"])
        self.certs_dir = Path(self.config["nginx"].get("certs_dir", "/etc/nginx/ssl/cdn"))
        self.reload_command = self.config["nginx"]["reload_command"]
        self.test_command = self.config["nginx"].get("test_command", "nginx -t")
        self.update_interval = int(self.config.get("update_interval", 30))
        self.request_timeout = float(self.config.get("request_timeout", 10.0))

        # Create certs directory
        self.certs_dir.mkdir(parents=True, exist_ok=True)
        
        # Ensure log format config exists
        self.ensure_log_format_config()

    def get_system_metrics(self) -> Dict[str, float]:
        """Get system metrics"""
        try:
            return {
                "cpu_usage": psutil.cpu_percent(interval=None),
                "memory_usage": psutil.virtual_memory().percent,
                "disk_usage": psutil.disk_usage('/').percent,
                "active_connections": len(psutil.net_connections())
            }
        except Exception as e:
            logger.error(f"Failed to get metrics: {e}")
            return {}

    async def send_heartbeat(self):
        """Send heartbeat with metrics"""
        metrics = self.get_system_metrics()
        url = f"{self.control_plane_url}/internal/edge/heartbeat"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }
        
        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                await client.post(url, json=metrics, headers=headers)
                logger.debug("Heartbeat sent")
        except Exception as e:
            logger.error(f"Failed to send heartbeat: {e}")

    def ensure_log_format_config(self):
        """Write the log format configuration file"""
        try:
            conf_path = Path("/etc/nginx/conf.d/00_cdn_log_format.conf")
            # Only write if content differs or file missing
            if not conf_path.exists() or conf_path.read_text().strip() != LOG_FORMAT_CONF.strip():
                conf_path.parent.mkdir(parents=True, exist_ok=True)
                conf_path.write_text(LOG_FORMAT_CONF)
                logger.info("Wrote Nginx log format config to %s", conf_path)
        except Exception as e:
            logger.error("Failed to write log format config: %s", e)

    async def fetch_config(self) -> Optional[Dict[str, Any]]:
        """Fetch configuration from control plane"""
        url = f"{self.control_plane_url}/internal/edge/config"
        params = {
            "node_id": self.node_id,
            "version": self.current_version,
        }
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.get(url, params=params, headers=headers)
                # 304 / 204 = нет изменений
                if response.status_code in (204, 304):
                    logger.debug("Control plane: config not modified (%s)", response.status_code)
                    return None
                response.raise_for_status()
                
                # Inject global settings into config for template access
                config = response.json()
                config['global_settings'] = config.get('global_settings', {})
                config['global_settings']['acme_url'] = self.control_plane_url
                
                return config
        except Exception as e:
            logger.error("Failed to fetch config: %s", e)
            return None

    async def fetch_certificate(self, cert_id: int) -> Optional[Dict[str, str]]:
        """Fetch certificate content"""
        url = f"{self.control_plane_url}/internal/edge/certificates/{cert_id}"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.get(url, headers=headers)
                if response.status_code == 404:
                    logger.warning("Certificate %s not found in control plane", cert_id)
                    return None
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error("Failed to fetch certificate %s: %s", cert_id, e)
            return None

    async def process_certificates(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Process certificates for domains and normalize domain structures"""
        domains: List[Dict[str, Any]] = config.get("domains") or []
        processed: List[Dict[str, Any]] = []

        for domain in domains:
            # Нормализуем структуру домена, чтобы шаблон не падал
            tls = domain.get("tls") or {}
            domain["tls"] = tls
            domain.setdefault("cache_rules", [])
            domain.setdefault("waf_rules", [])
            origins = domain.get("origins") or []
            if not origins:
                logger.warning("Domain %s has no origins defined, skipping", domain.get("name"))
                continue

            # TLS / сертификаты
            if tls.get("enabled") and tls.get("certificate_id"):
                cert_id = tls["certificate_id"]
                cert_data = await self.fetch_certificate(cert_id)

                if cert_data:
                    cert_path = self.certs_dir / f"{domain['name']}.crt"
                    key_path = self.certs_dir / f"{domain['name']}.key"

                    # Write certificate (full chain)
                    with open(cert_path, "w") as f:
                        f.write(cert_data["certificate"])
                        chain = cert_data.get("chain")
                        if chain:
                            f.write("\n")
                            f.write(chain)

                    # Write private key
                    with open(key_path, "w") as f:
                        f.write(cert_data["private_key"])

                    # Set permission for key file
                    os.chmod(key_path, 0o600)

                    # Update domain config with paths
                    domain["tls_certificate"] = {
                        "cert_path": str(cert_path),
                        "key_path": str(key_path),
                    }
                else:
                    logger.warning(
                        "Could not fetch certificate %s for %s, disabling TLS for this domain",
                        cert_id,
                        domain.get("name"),
                    )
                    tls["enabled"] = False
                    # Если TLS отвалился — не пытаемся форсить HTTPS
                    if "force_https" in tls:
                        tls["force_https"] = False
                    domain.pop("tls_certificate", None)
            else:
                # На всякий случай сбрасываем tls_certificate если TLS выключен
                domain.pop("tls_certificate", None)

            # Ensure tls_settings exists for template compatibility
            domain["tls_settings"] = tls

            processed.append(domain)

        config["domains"] = processed
        # Добавим timestamp если не пришёл
        config.setdefault("timestamp", datetime.utcnow().isoformat())
        return config

    def generate_nginx_config(self, config: Dict[str, Any]) -> str:
        """Generate Nginx configuration from config data"""
        return NGINX_TEMPLATE.render(**config)

    def reload_nginx(self) -> bool:
        """Reload Nginx configuration"""
        try:
            # Test configuration first
            test_cmd = shlex.split(self.test_command)
            result = subprocess.run(
                test_cmd,
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                logger.error("Nginx config test failed: %s", result.stderr.strip())
                return False

            # Reload Nginx
            reload_cmd = shlex.split(self.reload_command)
            result = subprocess.run(
                reload_cmd,
                capture_output=True,
                text=True,
            )

            if result.returncode == 0:
                logger.info("Nginx reloaded successfully")
                return True
            else:
                logger.error("Nginx reload failed: %s", result.stderr.strip())
                return False

        except Exception as e:
            logger.error("Failed to reload Nginx: %s", e)
            return False

    async def update_config(self):
        """Fetch and apply new configuration"""
        raw_config = await self.fetch_config()

        if not raw_config:
            logger.debug("No config received (or not modified)")
            return

        version = raw_config.get("version", 0)
        changed = raw_config.get("changed", False)

        if version <= self.current_version and not changed:
            logger.debug("Config is up to date (remote_version=%s, local=%s)", version, self.current_version)
            return

        logger.info("New config version received: %s", version)

        # Process certificates and normalize
        config = await self.process_certificates(raw_config)

        # Generate Nginx config
        nginx_config = self.generate_nginx_config(config)

        # Pre-create cache directories (otherwise Nginx fails if they don't exist)
        if config.get("domains"):
            for domain in config["domains"]:
                safe_name = domain["name"].replace('.', '_')
                cache_path = Path(f"/var/cache/nginx/{safe_name}")
                try:
                    cache_path.mkdir(parents=True, exist_ok=True)
                    # Optional: Set permissions? Assuming script runs as root/privileged
                    # os.chown(str(cache_path), nginx_uid, nginx_gid)
                except Exception as e:
                    logger.warning("Failed to create cache dir %s: %s", cache_path, e)

        # Write to file
        self.nginx_config_path.parent.mkdir(parents=True, exist_ok=True)
        self.nginx_config_path.write_text(nginx_config)

        # Reload Nginx
        if self.reload_nginx():
            self.current_version = version
            logger.info("Config updated to version %s", self.current_version)
        else:
            logger.error("Failed to reload Nginx, keeping old config in memory")

    async def run(self):
        """Main loop"""
        logger.info("Edge Config Updater started (node_id=%s, interval=%ss)", self.node_id, self.update_interval)
        
        # Start log shipper in background
        log_shipper = LogShipper(self.config, self.api_key)
        asyncio.create_task(log_shipper.run())

        while True:
            try:
                # Send heartbeat
                await self.send_heartbeat()
                
                # Update config
                await self.update_config()
            except Exception as e:
                logger.error("Error in update loop: %s", e, exc_info=True)

            await asyncio.sleep(self.update_interval)


async def main():
    """Main entry point"""
    updater = EdgeConfigUpdater()
    await updater.run()


if __name__ == "__main__":
    asyncio.run(main())
