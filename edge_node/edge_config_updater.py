"""
Edge Node Configuration Updater

This script runs on edge nodes and periodically fetches configuration
from the control plane, then updates Nginx/OpenResty configuration.
"""
import asyncio
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, Any, Optional

import httpx
import yaml
from jinja2 import Template


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class EdgeConfigUpdater:
    """Edge node configuration updater"""
    
    def __init__(self, config_path: str = "config.yaml"):
        with open(config_path) as f:
            self.config = yaml.safe_load(f)
        
        self.node_id = self.config['edge_node']['id']
        self.control_plane_url = self.config['control_plane']['url']
        self.api_key = self.config['control_plane']['api_key']
        self.current_version = 0
        
        self.nginx_config_path = Path(self.config['nginx']['config_path'])
        self.reload_command = self.config['nginx']['reload_command']
        
    async def fetch_config(self) -> Optional[Dict[str, Any]]:
        """Fetch configuration from control plane"""
        url = f"{self.control_plane_url}/internal/edge/config"
        params = {
            "node_id": self.node_id,
            "version": self.current_version
        }
        headers = {
            "Authorization": f"Bearer {self.api_key}"
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url, params=params, headers=headers)
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"Failed to fetch config: {e}")
            return None
    
    def generate_nginx_config(self, config: Dict[str, Any]) -> str:
        """Generate Nginx configuration from config data"""
        template = Template("""
# Generated by Edge Config Updater
# Version: {{ version }}
# Generated at: {{ timestamp }}

{% for domain in domains %}
# Domain: {{ domain.name }}
upstream {{ domain.name|replace('.', '_') }}_backend {
    {% for origin in domain.origins %}
    server {{ origin.origin_host }}:{{ origin.origin_port }} weight={{ origin.weight }} {% if origin.is_backup %}backup{% endif %};
    {% endfor %}
}

server {
    listen 443 ssl http2;
    server_name {{ domain.name }};
    
    {% if domain.tls_certificate %}
    ssl_certificate {{ domain.tls_certificate.cert_path }};
    ssl_certificate_key {{ domain.tls_certificate.key_path }};
    {% endif %}
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    
    {% if domain.tls_settings.hsts_enabled %}
    add_header Strict-Transport-Security "max-age={{ domain.tls_settings.hsts_max_age }}{% if domain.tls_settings.hsts_include_subdomains %}; includeSubDomains{% endif %}" always;
    {% endif %}
    
    # Cache configuration
    proxy_cache_path /var/cache/nginx/{{ domain.name|replace('.', '_') }} levels=1:2 keys_zone={{ domain.name|replace('.', '_') }}:10m max_size=1g;
    
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ domain.name|replace('.', '_') }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}
        
        proxy_pass https://{{ domain.name|replace('.', '_') }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    
    location / {
        proxy_pass https://{{ domain.name|replace('.', '_') }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

{% if domain.tls_settings.force_https %}
server {
    listen 80;
    server_name {{ domain.name }};
    return 301 https://$host$request_uri;
}
{% endif %}

{% endfor %}
        """)
        
        return template.render(**config)
    
    def reload_nginx(self) -> bool:
        """Reload Nginx configuration"""
        try:
            # Test configuration first
            result = subprocess.run(
                ["nginx", "-t"],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                logger.error(f"Nginx config test failed: {result.stderr}")
                return False
            
            # Reload Nginx
            result = subprocess.run(
                self.reload_command.split(),
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                logger.info("Nginx reloaded successfully")
                return True
            else:
                logger.error(f"Nginx reload failed: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to reload Nginx: {e}")
            return False
    
    async def update_config(self):
        """Fetch and apply new configuration"""
        config = await self.fetch_config()
        
        if not config:
            logger.warning("No config received")
            return
        
        if config.get('version', 0) <= self.current_version:
            logger.debug("Config is up to date")
            return
        
        logger.info(f"New config version: {config['version']}")
        
        # Generate Nginx config
        nginx_config = self.generate_nginx_config(config)
        
        # Write to file
        self.nginx_config_path.parent.mkdir(parents=True, exist_ok=True)
        self.nginx_config_path.write_text(nginx_config)
        
        # Reload Nginx
        if self.reload_nginx():
            self.current_version = config['version']
            logger.info(f"Config updated to version {self.current_version}")
        else:
            logger.error("Failed to reload Nginx, keeping old config")
    
    async def run(self):
        """Main loop"""
        update_interval = self.config.get('update_interval', 30)
        
        logger.info(f"Edge Config Updater started (node_id={self.node_id})")
        
        while True:
            try:
                await self.update_config()
            except Exception as e:
                logger.error(f"Error in update loop: {e}", exc_info=True)
            
            await asyncio.sleep(update_interval)


async def main():
    """Main entry point"""
    updater = EdgeConfigUpdater()
    await updater.run()


if __name__ == "__main__":
    asyncio.run(main())


