"""
Edge Node Configuration Updater

This script runs on edge nodes and periodically fetches configuration
from the control plane, then updates Nginx/OpenResty configuration.
"""
import asyncio
import json
import logging
import subprocess
import os
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime
import shlex

import httpx
import yaml
from jinja2 import Template


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


NGINX_TEMPLATE = Template("""
# Generated by Edge Config Updater
# Version: {{ version|default('unknown') }}
# Generated at: {{ timestamp|default('') }}

{% for domain in domains %}
{% set safe_name = domain.name|replace('.', '_') %}

# Domain: {{ domain.name }}

# Cache zone for this domain (http context)
proxy_cache_path /var/cache/nginx/{{ safe_name }} levels=1:2 keys_zone={{ safe_name }}:10m max_size=1g inactive=10m use_temp_path=off;

upstream {{ safe_name }}_backend {
    {% for origin in domain.origins %}
    server {{ origin.host }}:{{ origin.port }} weight={{ origin.weight }} {% if origin.is_backup %}backup{% endif %};
    {% endfor %}
}

{# HTTPS server if TLS is enabled and certificate is available #}
{% if domain.tls_settings.enabled and domain.tls_certificate %}
server {
    listen 443 ssl http2;
    server_name {{ domain.name }};

    ssl_certificate {{ domain.tls_certificate.cert_path }};
    ssl_certificate_key {{ domain.tls_certificate.key_path }};

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    {% if domain.tls_settings.hsts_enabled %}
    add_header Strict-Transport-Security "max-age={{ domain.tls_settings.hsts_max_age|default(31536000) }}{% if domain.tls_settings.hsts_include_subdomains %}; includeSubDomains{% endif %}" always;
    {% endif %}

    {% if domain.cache_rules %}
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ safe_name }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}

        proxy_pass {{ domain.origins[0].protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    {% endif %}

    location / {
        proxy_pass {{ domain.origins[0].protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
{% if domain.tls_settings.force_https %}
server {
    listen 80;
    server_name {{ domain.name }};
    return 301 https://$host$request_uri;
}
{% endif %}
{% else %}
# HTTP-only domain (TLS disabled or certificate unavailable)
server {
    listen 80;
    server_name {{ domain.name }};

    {% if domain.cache_rules %}
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ safe_name }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}

        proxy_pass {{ domain.origins[0].protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    {% endif %}

    location / {
        proxy_pass {{ domain.origins[0].protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
{% endif %}

{% endfor %}
""")


class EdgeConfigUpdater:
    """Edge node configuration updater"""

    def __init__(self, config_path: str = "config.yaml"):
        # Путь к конфигу можно переопределить через env,
        # относительный путь считаем от директории скрипта.
        config_path = os.getenv("EDGE_UPDATER_CONFIG", config_path)
        config_file = Path(config_path)
        if not config_file.is_absolute():
            config_file = Path(__file__).resolve().parent / config_file

        with open(config_file) as f:
            self.config = yaml.safe_load(f)

        self.node_id = self.config["edge_node"]["id"]
        self.control_plane_url = self.config["control_plane"]["url"].rstrip("/")
        self.api_key = self.config["control_plane"]["api_key"]
        self.current_version = 0

        self.nginx_config_path = Path(self.config["nginx"]["config_path"])
        self.certs_dir = Path(self.config["nginx"].get("certs_dir", "/etc/nginx/ssl/cdn"))
        self.reload_command = self.config["nginx"]["reload_command"]
        self.test_command = self.config["nginx"].get("test_command", "nginx -t")
        self.update_interval = int(self.config.get("update_interval", 30))
        self.request_timeout = float(self.config.get("request_timeout", 10.0))

        # Create certs directory
        self.certs_dir.mkdir(parents=True, exist_ok=True)

    async def fetch_config(self) -> Optional[Dict[str, Any]]:
        """Fetch configuration from control plane"""
        url = f"{self.control_plane_url}/internal/edge/config"
        params = {
            "node_id": self.node_id,
            "version": self.current_version,
        }
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.get(url, params=params, headers=headers)
                # 304 / 204 = нет изменений
                if response.status_code in (204, 304):
                    logger.debug("Control plane: config not modified (%s)", response.status_code)
                    return None
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error("Failed to fetch config: %s", e)
            return None

    async def fetch_certificate(self, cert_id: int) -> Optional[Dict[str, str]]:
        """Fetch certificate content"""
        url = f"{self.control_plane_url}/internal/edge/certificates/{cert_id}"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.get(url, headers=headers)
                if response.status_code == 404:
                    logger.warning("Certificate %s not found in control plane", cert_id)
                    return None
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error("Failed to fetch certificate %s: %s", cert_id, e)
            return None

    async def process_certificates(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Process certificates for domains and normalize domain structures"""
        domains: List[Dict[str, Any]] = config.get("domains") or []
        processed: List[Dict[str, Any]] = []

        for domain in domains:
            # Нормализуем структуру домена, чтобы шаблон не падал
            tls = domain.get("tls") or {}
            domain["tls"] = tls
            domain.setdefault("cache_rules", [])
            domain.setdefault("waf_rules", [])
            origins = domain.get("origins") or []
            if not origins:
                logger.warning("Domain %s has no origins defined, skipping", domain.get("name"))
                continue

            # TLS / сертификаты
            if tls.get("enabled") and tls.get("certificate_id"):
                cert_id = tls["certificate_id"]
                cert_data = await self.fetch_certificate(cert_id)

                if cert_data:
                    cert_path = self.certs_dir / f"{domain['name']}.crt"
                    key_path = self.certs_dir / f"{domain['name']}.key"

                    # Write certificate (full chain)
                    with open(cert_path, "w") as f:
                        f.write(cert_data["certificate"])
                        chain = cert_data.get("chain")
                        if chain:
                            f.write("\n")
                            f.write(chain)

                    # Write private key
                    with open(key_path, "w") as f:
                        f.write(cert_data["private_key"])

                    # Set permission for key file
                    os.chmod(key_path, 0o600)

                    # Update domain config with paths
                    domain["tls_certificate"] = {
                        "cert_path": str(cert_path),
                        "key_path": str(key_path),
                    }
                else:
                    logger.warning(
                        "Could not fetch certificate %s for %s, disabling TLS for this domain",
                        cert_id,
                        domain.get("name"),
                    )
                    tls["enabled"] = False
                    # Если TLS отвалился — не пытаемся форсить HTTPS
                    if "force_https" in tls:
                        tls["force_https"] = False
                    domain.pop("tls_certificate", None)
            else:
                # На всякий случай сбрасываем tls_certificate если TLS выключен
                domain.pop("tls_certificate", None)

            # Ensure tls_settings exists for template compatibility
            domain["tls_settings"] = tls

            processed.append(domain)

        config["domains"] = processed
        # Добавим timestamp если не пришёл
        config.setdefault("timestamp", datetime.utcnow().isoformat())
        return config

    def generate_nginx_config(self, config: Dict[str, Any]) -> str:
        """Generate Nginx configuration from config data"""
        return NGINX_TEMPLATE.render(**config)

    def reload_nginx(self) -> bool:
        """Reload Nginx configuration"""
        try:
            # Test configuration first
            test_cmd = shlex.split(self.test_command)
            result = subprocess.run(
                test_cmd,
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                logger.error("Nginx config test failed: %s", result.stderr.strip())
                return False

            # Reload Nginx
            reload_cmd = shlex.split(self.reload_command)
            result = subprocess.run(
                reload_cmd,
                capture_output=True,
                text=True,
            )

            if result.returncode == 0:
                logger.info("Nginx reloaded successfully")
                return True
            else:
                logger.error("Nginx reload failed: %s", result.stderr.strip())
                return False

        except Exception as e:
            logger.error("Failed to reload Nginx: %s", e)
            return False

    async def update_config(self):
        """Fetch and apply new configuration"""
        raw_config = await self.fetch_config()

        if not raw_config:
            logger.debug("No config received (or not modified)")
            return

        version = raw_config.get("version", 0)
        changed = raw_config.get("changed", False)

        if version <= self.current_version and not changed:
            logger.debug("Config is up to date (remote_version=%s, local=%s)", version, self.current_version)
            return

        logger.info("New config version received: %s", version)

        # Process certificates and normalize
        config = await self.process_certificates(raw_config)

        # Generate Nginx config
        nginx_config = self.generate_nginx_config(config)

        # Write to file
        self.nginx_config_path.parent.mkdir(parents=True, exist_ok=True)
        self.nginx_config_path.write_text(nginx_config)

        # Reload Nginx
        if self.reload_nginx():
            self.current_version = version
            logger.info("Config updated to version %s", self.current_version)
        else:
            logger.error("Failed to reload Nginx, keeping old config in memory")

    async def run(self):
        """Main loop"""
        logger.info("Edge Config Updater started (node_id=%s, interval=%ss)", self.node_id, self.update_interval)

        while True:
            try:
                await self.update_config()
            except Exception as e:
                logger.error("Error in update loop: %s", e, exc_info=True)

            await asyncio.sleep(self.update_interval)


async def main():
    """Main entry point"""
    updater = EdgeConfigUpdater()
    await updater.run()


if __name__ == "__main__":
    asyncio.run(main())
