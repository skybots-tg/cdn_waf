"""
Edge Node Configuration Updater

This script runs on edge nodes and periodically fetches configuration
from the control plane, then updates Nginx/OpenResty configuration.
"""
import asyncio
import json
import logging
import subprocess
import os
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime
import shlex
import aiofiles
import psutil

import httpx
import yaml
from jinja2 import Template


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


LOG_FORMAT_CONF = """
# Generated by Edge Config Updater
# Note: $geoip2_data_country_code will be empty if GeoIP2 module is not available
# We'll use IP-based lookup in the log shipper as fallback

# Define default value for geoip2_data_country_code (empty string if GeoIP2 not available)
# This map ensures the variable is always defined, even without GeoIP2 module
map $remote_addr $geoip2_data_country_code {
    default "";
}

# GeoIP2 configuration (if module is available, uncomment and configure)
# This will override the default empty value set by the map above
# geoip2 /usr/share/GeoIP/GeoLite2-Country.mmdb {
#     $geoip2_data_country_code country iso_code;
# }

log_format cdn_json_log escape=json '{'
    '"timestamp": "$time_iso8601",'
    '"domain": "$host",'
    '"client_ip": "$remote_addr",'
    '"method": "$request_method",'
    '"path": "$request_uri",'
    '"status": $status,'
    '"bytes_sent": $body_bytes_sent,'
    '"referer": "$http_referer",'
    '"user_agent": "$http_user_agent",'
    '"request_time": $request_time,'
    '"cache_status": "$upstream_cache_status",'
    '"country_code": "$geoip2_data_country_code"'
'}';
"""

NGINX_TEMPLATE = Template("""
# Generated by Edge Config Updater
# Version: {{ version|default('unknown') }}
# Generated at: {{ timestamp|default('') }}

# ============================================
# Cache zones for all domains (must be in http context)
# ============================================
{% for domain in domains %}
{% set safe_name = domain.name|replace('.', '_') %}
proxy_cache_path /var/cache/nginx/{{ safe_name }} levels=1:2 keys_zone={{ safe_name }}:10m max_size=1g inactive=10m use_temp_path=off;
{% endfor %}

# ============================================
# Upstream definitions
# ============================================
{% for domain in domains %}
{% set safe_name = domain.name|replace('.', '_') %}
{% set backend_protocol = 'https' if domain.tls_settings.mode in ['full', 'strict'] else 'http' %}
upstream {{ safe_name }}_backend {
    {% for origin in domain.origins %}
    server {{ origin.host }}:{{ origin.port if backend_protocol == 'http' else (443 if origin.port == 80 else origin.port) }} weight={{ origin.weight }} {% if origin.is_backup %}backup{% endif %};
    {% endfor %}
}
{% endfor %}

# ============================================
# Default server for unconfigured domains (HTTP)
# ============================================
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    
    access_log /var/log/nginx/default_access.log;
    
    # Health check endpoint
    location /health {
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }
    
    # ACME Challenge support for any domain (even unconfigured)
    location /.well-known/acme-challenge/ {
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host {{ global_settings.control_plane_url|default('https://flarecloud.ru')|replace('https://', '')|replace('http://', '') }};
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host $host;
    }
    
    # Return 404 for all other requests to unconfigured domains
    location / {
        return 404 "Domain not configured on this CDN node\n";
    }
}

# ============================================
# Default server for unconfigured domains (HTTPS)
# This prevents wrong certificate being served when SNI doesn't match
# ============================================
server {
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    server_name _;
    
    # Use self-signed/dummy certificate for default server
    # These will be generated on first run if they don't exist
    ssl_certificate /etc/nginx/ssl/cdn/default.crt;
    ssl_certificate_key /etc/nginx/ssl/cdn/default.key;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    
    # Reject connections to unconfigured domains
    # Return 421 Misdirected Request - indicates wrong server for this domain
    return 421 "Domain not configured on this CDN node\n";
}

# ============================================
# Domain configurations
# ============================================
{% for domain in domains %}
{% set safe_name = domain.name|replace('.', '_') %}
{% set backend_protocol = 'https' if domain.tls_settings.mode in ['full', 'strict'] else 'http' %}

# ----------------------------------------
# Domain: {{ domain.name }}
# ----------------------------------------

{% if domain.tls_settings.enabled and domain.tls_certificate %}
{# HTTPS server block #}
server {
    listen 443 ssl http2;
    server_name {{ domain.name }};

    access_log /var/log/nginx/cdn_access.json.log cdn_json_log;

    ssl_certificate {{ domain.tls_certificate.cert_path }};
    ssl_certificate_key {{ domain.tls_certificate.key_path }};

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    {% if domain.tls_settings.hsts_enabled %}
    add_header Strict-Transport-Security "max-age={{ domain.tls_settings.hsts_max_age|default(31536000) }}{% if domain.tls_settings.hsts_include_subdomains %}; includeSubDomains{% endif %}" always;
    {% endif %}

    {% if domain.cache_rules %}
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ safe_name }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}

        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    {% endif %}

    location / {
        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ACME Challenge support (HTTP-01)
    location /.well-known/acme-challenge/ {
        # Proxy to control plane public endpoint (no auth required)
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host {{ global_settings.control_plane_url|default('https://flarecloud.ru')|replace('https://', '')|replace('http://', '') }};
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
# HTTP server for ACME challenges (always present when TLS enabled)
server {
    listen 80;
    server_name {{ domain.name }};
    access_log /var/log/nginx/cdn_access.json.log cdn_json_log;
    
    # ACME Challenge support (HTTP-01)
    location /.well-known/acme-challenge/ {
        # Proxy to control plane public endpoint (no auth required)
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host {{ global_settings.control_plane_url|default('https://flarecloud.ru')|replace('https://', '')|replace('http://', '') }};
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
{% if domain.tls_settings.force_https %}
    # Redirect all other HTTP traffic to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
{% else %}
    # Allow HTTP traffic (no redirect)
    location / {
        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
{% endif %}
}

{% else %}
# HTTP-only domain (TLS disabled or certificate unavailable)
server {
    listen 80;
    server_name {{ domain.name }};
    access_log /var/log/nginx/cdn_access.json.log cdn_json_log;

    {% if domain.cache_rules %}
    {% for rule in domain.cache_rules %}
    location ~ {{ rule.pattern }} {
        proxy_cache {{ safe_name }};
        {% if rule.ttl %}
        proxy_cache_valid 200 {{ rule.ttl }}s;
        {% endif %}

        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        {% for waf_rule in domain.waf_rules %}
        # WAF Rule: {{ waf_rule.name }}
        {% if waf_rule.action == 'block' %}
        # TODO: Implement WAF blocking
        {% endif %}
        {% endfor %}
    }
    {% endfor %}
    {% endif %}

    location / {
        proxy_pass {{ backend_protocol }}://{{ safe_name }}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # ACME Challenge support (HTTP-01)
    location /.well-known/acme-challenge/ {
        # Proxy to control plane public endpoint (no auth required)
        proxy_pass {{ global_settings.control_plane_url|default('https://flarecloud.ru') }}/.well-known/acme-challenge/;
        proxy_set_header Host {{ global_settings.control_plane_url|default('https://flarecloud.ru')|replace('https://', '')|replace('http://', '') }};
    }
}
{% endif %}

{% endfor %}
""")


class GeoIPLookup:
    """GeoIP lookup using MaxMind GeoLite2 database"""
    
    def __init__(self):
        self.reader = None
        self.db_paths = [
            "/usr/share/GeoIP/GeoLite2-Country.mmdb",
            "/var/lib/GeoIP/GeoLite2-Country.mmdb",
            "/opt/cdn_waf/GeoLite2-Country.mmdb",
        ]
        self._init_reader()
    
    def _init_reader(self):
        """Initialize GeoIP reader if database exists"""
        try:
            import geoip2.database
            for db_path in self.db_paths:
                if Path(db_path).exists():
                    self.reader = geoip2.database.Reader(db_path)
                    logger.info("GeoIP database loaded from %s", db_path)
                    return
            logger.warning("GeoIP database not found, geo lookups will be skipped")
        except ImportError:
            logger.warning("geoip2 module not installed, geo lookups will be skipped")
        except Exception as e:
            logger.warning("Failed to load GeoIP database: %s", e)
    
    def lookup(self, ip: str) -> Optional[str]:
        """Look up country code for an IP address"""
        if not self.reader:
            return None
        
        try:
            response = self.reader.country(ip)
            return response.country.iso_code
        except Exception:
            return None
    
    def close(self):
        """Close the GeoIP reader"""
        if self.reader:
            self.reader.close()


class LogShipper:
    """Reads Nginx JSON logs and ships them to the control plane"""
    
    def __init__(self, config: Dict[str, Any], api_key: str):
        self.config = config
        self.api_key = api_key
        self.node_id = config["edge_node"]["id"]
        self.control_plane_url = config["control_plane"]["url"].rstrip("/")
        self.log_file = Path("/var/log/nginx/cdn_access.json.log")
        self.batch_size = 100
        self.poll_interval = 1.0
        self.request_timeout = 10.0
        self.geoip = GeoIPLookup()
    
    def enrich_log_entry(self, log_entry: Dict[str, Any]) -> Dict[str, Any]:
        """Enrich log entry with additional data like country code"""
        # If country_code is missing or empty, try GeoIP lookup
        country_code = log_entry.get("country_code")
        if not country_code or country_code in ("", "-", "$geoip2_data_country_code"):
            client_ip = log_entry.get("client_ip")
            if client_ip:
                country_code = self.geoip.lookup(client_ip)
                if country_code:
                    log_entry["country_code"] = country_code
                else:
                    log_entry["country_code"] = None
        
        return log_entry
    
    async def send_logs(self, logs: List[Dict[str, Any]]) -> bool:
        url = f"{self.control_plane_url}/internal/edge/logs"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }
        
        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.post(url, json=logs, headers=headers)
                response.raise_for_status()
                return True
        except Exception as e:
            logger.error("Failed to ship logs: %s", e)
            return False

    async def run(self):
        logger.info("Log Shipper started (file=%s)", self.log_file)
        
        while True:
            if not self.log_file.exists():
                await asyncio.sleep(5)
                continue
                
            try:
                # Open file and tail it
                async with aiofiles.open(self.log_file, mode='r') as f:
                    # Seek to end initially
                    await f.seek(0, 2)
                    
                    batch = []
                    last_send = datetime.now()
                    
                    while True:
                        line = await f.readline()
                        if line:
                            try:
                                log_entry = json.loads(line)
                                # Enrich with geo data
                                log_entry = self.enrich_log_entry(log_entry)
                                batch.append(log_entry)
                            except json.JSONDecodeError:
                                logger.warning("Invalid JSON in log line")
                                continue
                        else:
                            await asyncio.sleep(self.poll_interval)
                        
                        # Send if batch full or time elapsed (every 5 seconds)
                        now = datetime.now()
                        if len(batch) >= self.batch_size or (batch and (now - last_send).total_seconds() > 5):
                            if await self.send_logs(batch):
                                batch = []
                                last_send = now
                            else:
                                # Keep batch and retry next loop
                                await asyncio.sleep(2)
                                
            except Exception as e:
                logger.error("Error in log shipper loop: %s", e)
                await asyncio.sleep(5)


class EdgeConfigUpdater:
    """Edge node configuration updater"""

    def __init__(self, config_path: str = "config.yaml"):
        # Путь к конфигу можно переопределить через env,
        # относительный путь считаем от директории скрипта.
        env_config = os.getenv("EDGE_UPDATER_CONFIG")
        if env_config:
            config_path = env_config
        
        config_file = Path(config_path)
        if not config_file.is_absolute():
            config_file = Path(__file__).resolve().parent / config_file

        with open(config_file) as f:
            self.config = yaml.safe_load(f)

        self.node_id = self.config["edge_node"]["id"]
        self.control_plane_url = self.config["control_plane"]["url"].rstrip("/")
        self.api_key = self.config["control_plane"]["api_key"]
        self.current_version = 0

        self.nginx_config_path = Path(self.config["nginx"]["config_path"])
        self.certs_dir = Path(self.config["nginx"].get("certs_dir", "/etc/nginx/ssl/cdn"))
        self.reload_command = self.config["nginx"]["reload_command"]
        self.test_command = self.config["nginx"].get("test_command", "nginx -t")
        self.update_interval = int(self.config.get("update_interval", 30))
        self.request_timeout = float(self.config.get("request_timeout", 15.0))

        # Create certs directory with proper permissions
        try:
            self.certs_dir.mkdir(parents=True, exist_ok=True)
            os.chmod(self.certs_dir, 0o700)
        except PermissionError:
            logger.warning("Could not set permissions on certs dir: %s", self.certs_dir)
        
        # Ensure default certificate exists for HTTPS default_server
        self.ensure_default_certificate()
        
        # Ensure log format config exists
        self.ensure_log_format_config()
        
        logger.info("EdgeConfigUpdater initialized (node_id=%s, control_plane=%s)", 
                   self.node_id, self.control_plane_url)

    def get_system_metrics(self) -> Dict[str, float]:
        """Get system metrics"""
        try:
            return {
                "cpu_usage": psutil.cpu_percent(interval=None),
                "memory_usage": psutil.virtual_memory().percent,
                "disk_usage": psutil.disk_usage('/').percent,
                "active_connections": len(psutil.net_connections())
            }
        except Exception as e:
            logger.error(f"Failed to get metrics: {e}")
            return {}

    async def send_heartbeat(self):
        """Send heartbeat with metrics"""
        metrics = self.get_system_metrics()
        url = f"{self.control_plane_url}/internal/edge/heartbeat"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }
        
        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                await client.post(url, json=metrics, headers=headers)
                logger.debug("Heartbeat sent")
        except Exception as e:
            logger.error(f"Failed to send heartbeat: {e}")

    def ensure_default_certificate(self):
        """Ensure a self-signed certificate exists for the HTTPS default_server"""
        cert_path = self.certs_dir / "default.crt"
        key_path = self.certs_dir / "default.key"
        
        if cert_path.exists() and key_path.exists():
            logger.debug("Default certificate already exists")
            return
        
        logger.info("Generating self-signed default certificate...")
        
        try:
            # Try using openssl command (most compatible)
            result = subprocess.run([
                "openssl", "req", "-x509", "-nodes",
                "-days", "3650",
                "-newkey", "rsa:2048",
                "-keyout", str(key_path),
                "-out", str(cert_path),
                "-subj", "/CN=localhost/O=CDN Default/C=US"
            ], capture_output=True, text=True)
            
            if result.returncode == 0:
                os.chmod(key_path, 0o600)
                logger.info("Generated default self-signed certificate")
            else:
                logger.error("Failed to generate default certificate: %s", result.stderr)
        except FileNotFoundError:
            logger.warning("openssl not found, trying Python cryptography...")
            try:
                from cryptography import x509
                from cryptography.x509.oid import NameOID
                from cryptography.hazmat.primitives import hashes, serialization
                from cryptography.hazmat.primitives.asymmetric import rsa
                from cryptography.hazmat.backends import default_backend
                from datetime import datetime, timedelta
                
                # Generate key
                key = rsa.generate_private_key(
                    public_exponent=65537,
                    key_size=2048,
                    backend=default_backend()
                )
                
                # Generate certificate
                subject = issuer = x509.Name([
                    x509.NameAttribute(NameOID.COMMON_NAME, "localhost"),
                    x509.NameAttribute(NameOID.ORGANIZATION_NAME, "CDN Default"),
                ])
                
                cert = (
                    x509.CertificateBuilder()
                    .subject_name(subject)
                    .issuer_name(issuer)
                    .public_key(key.public_key())
                    .serial_number(x509.random_serial_number())
                    .not_valid_before(datetime.utcnow())
                    .not_valid_after(datetime.utcnow() + timedelta(days=3650))
                    .sign(key, hashes.SHA256(), default_backend())
                )
                
                # Write files
                with open(key_path, "wb") as f:
                    f.write(key.private_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PrivateFormat.TraditionalOpenSSL,
                        encryption_algorithm=serialization.NoEncryption()
                    ))
                os.chmod(key_path, 0o600)
                
                with open(cert_path, "wb") as f:
                    f.write(cert.public_bytes(serialization.Encoding.PEM))
                
                logger.info("Generated default self-signed certificate using cryptography")
            except Exception as e:
                logger.error("Failed to generate default certificate: %s", e)
        except Exception as e:
            logger.error("Failed to generate default certificate: %s", e)
    
    def ensure_log_format_config(self):
        """Write the log format configuration file"""
        try:
            conf_path = Path("/etc/nginx/conf.d/00_cdn_log_format.conf")
            # Only write if content differs or file missing
            if not conf_path.exists() or conf_path.read_text().strip() != LOG_FORMAT_CONF.strip():
                conf_path.parent.mkdir(parents=True, exist_ok=True)
                conf_path.write_text(LOG_FORMAT_CONF)
                logger.info("Wrote Nginx log format config to %s", conf_path)
        except Exception as e:
            logger.error("Failed to write log format config: %s", e)

    async def fetch_config(self) -> Optional[Dict[str, Any]]:
        """Fetch configuration from control plane"""
        url = f"{self.control_plane_url}/internal/edge/config"
        params = {
            "node_id": self.node_id,
            "version": self.current_version,
        }
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.get(url, params=params, headers=headers)
                # 304 / 204 = нет изменений
                if response.status_code in (204, 304):
                    logger.debug("Control plane: config not modified (%s)", response.status_code)
                    return None
                response.raise_for_status()
                
                # Get config from response
                config = response.json()
                
                # Ensure global_settings exists
                if 'global_settings' not in config:
                    config['global_settings'] = {}
                
                # Set control_plane_url if not provided by API
                if 'control_plane_url' not in config['global_settings']:
                    config['global_settings']['control_plane_url'] = self.control_plane_url
                
                return config
        except Exception as e:
            logger.error("Failed to fetch config: %s", e)
            return None

    async def fetch_certificate(self, cert_id: int) -> Optional[Dict[str, str]]:
        """Fetch certificate content"""
        url = f"{self.control_plane_url}/internal/edge/certificates/{cert_id}"
        headers = {
            "X-Node-Id": str(self.node_id),
            "X-Node-Token": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=self.request_timeout) as client:
                response = await client.get(url, headers=headers)
                if response.status_code == 404:
                    logger.warning("Certificate %s not found in control plane", cert_id)
                    return None
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error("Failed to fetch certificate %s: %s", cert_id, e)
            return None

    async def process_certificates(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Process certificates for domains and normalize domain structures"""
        domains: List[Dict[str, Any]] = config.get("domains") or []
        processed: List[Dict[str, Any]] = []

        for domain in domains:
            # Нормализуем структуру домена, чтобы шаблон не падал
            tls = domain.get("tls") or {}
            domain["tls"] = tls
            domain.setdefault("cache_rules", [])
            domain.setdefault("waf_rules", [])
            origins = domain.get("origins") or []
            if not origins:
                logger.warning("Domain %s has no origins defined, skipping", domain.get("name"))
                continue

            # TLS / сертификаты
            if tls.get("enabled") and tls.get("certificate_id"):
                cert_id = tls["certificate_id"]
                cert_data = await self.fetch_certificate(cert_id)

                if cert_data:
                    cert_path = self.certs_dir / f"{domain['name']}.crt"
                    key_path = self.certs_dir / f"{domain['name']}.key"

                    # Write certificate (full chain)
                    with open(cert_path, "w") as f:
                        f.write(cert_data["certificate"])
                        chain = cert_data.get("chain")
                        if chain:
                            f.write("\n")
                            f.write(chain)

                    # Write private key
                    with open(key_path, "w") as f:
                        f.write(cert_data["private_key"])

                    # Set permission for key file
                    os.chmod(key_path, 0o600)

                    # Update domain config with paths
                    domain["tls_certificate"] = {
                        "cert_path": str(cert_path),
                        "key_path": str(key_path),
                    }
                else:
                    logger.warning(
                        "Could not fetch certificate %s for %s, disabling TLS for this domain",
                        cert_id,
                        domain.get("name"),
                    )
                    tls["enabled"] = False
                    # Если TLS отвалился — не пытаемся форсить HTTPS
                    if "force_https" in tls:
                        tls["force_https"] = False
                    domain.pop("tls_certificate", None)
            else:
                # На всякий случай сбрасываем tls_certificate если TLS выключен
                domain.pop("tls_certificate", None)

            # Ensure tls_settings exists for template compatibility
            domain["tls_settings"] = tls

            processed.append(domain)

        config["domains"] = processed
        # Добавим timestamp если не пришёл
        config.setdefault("timestamp", datetime.utcnow().isoformat())
        return config

    def generate_nginx_config(self, config: Dict[str, Any]) -> str:
        """Generate Nginx configuration from config data"""
        # Ensure domains list exists (even if empty)
        if 'domains' not in config:
            config['domains'] = []
        
        # Ensure global_settings exists
        if 'global_settings' not in config:
            config['global_settings'] = {'control_plane_url': self.control_plane_url}
        
        return NGINX_TEMPLATE.render(**config)

    def reload_nginx(self) -> bool:
        """Reload Nginx configuration"""
        try:
            # Test configuration first
            test_cmd = shlex.split(self.test_command)
            result = subprocess.run(
                test_cmd,
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                logger.error("Nginx config test failed: %s", result.stderr.strip())
                return False

            # Reload Nginx (try reload first, fall back to restart if not running)
            reload_cmd = shlex.split(self.reload_command)
            result = subprocess.run(
                reload_cmd,
                capture_output=True,
                text=True,
            )

            if result.returncode == 0:
                logger.info("Nginx reloaded successfully")
                return True
            else:
                # Reload failed, try restart (nginx might not be running)
                logger.warning("Nginx reload failed, trying restart: %s", result.stderr.strip())
                restart_result = subprocess.run(
                    ["systemctl", "restart", "nginx"],
                    capture_output=True,
                    text=True,
                )
                if restart_result.returncode == 0:
                    logger.info("Nginx restarted successfully")
                    return True
                else:
                    logger.error("Nginx restart also failed: %s", restart_result.stderr.strip())
                    return False

        except Exception as e:
            logger.error("Failed to reload Nginx: %s", e)
            return False
    
    def backup_config(self) -> Optional[str]:
        """Backup current nginx config before overwriting"""
        if not self.nginx_config_path.exists():
            return None
        
        backup_path = self.nginx_config_path.with_suffix('.conf.bak')
        try:
            import shutil
            shutil.copy2(self.nginx_config_path, backup_path)
            return str(backup_path)
        except Exception as e:
            logger.warning("Failed to backup config: %s", e)
            return None
    
    def restore_config(self, backup_path: str) -> bool:
        """Restore nginx config from backup"""
        try:
            import shutil
            shutil.copy2(backup_path, self.nginx_config_path)
            logger.info("Restored config from backup")
            return True
        except Exception as e:
            logger.error("Failed to restore config from backup: %s", e)
            return False

    async def update_config(self):
        """Fetch and apply new configuration"""
        raw_config = await self.fetch_config()

        if not raw_config:
            logger.debug("No config received (or not modified)")
            return

        version = raw_config.get("version", 0)
        changed = raw_config.get("changed", False)

        if version <= self.current_version and not changed:
            logger.debug("Config is up to date (remote_version=%s, local=%s)", version, self.current_version)
            return

        logger.info("New config version received: %s", version)

        # Process certificates and normalize
        config = await self.process_certificates(raw_config)

        # Generate Nginx config
        nginx_config = self.generate_nginx_config(config)

        # Pre-create cache directories (otherwise Nginx fails if they don't exist)
        if config.get("domains"):
            for domain in config["domains"]:
                safe_name = domain["name"].replace('.', '_')
                cache_path = Path(f"/var/cache/nginx/{safe_name}")
                try:
                    cache_path.mkdir(parents=True, exist_ok=True)
                    # Set ownership to nginx user (www-data on Debian/Ubuntu, nginx on RHEL)
                    try:
                        import pwd
                        import grp
                        # Try www-data first (Ubuntu/Debian)
                        try:
                            uid = pwd.getpwnam('www-data').pw_uid
                            gid = grp.getgrnam('www-data').gr_gid
                        except KeyError:
                            # Fallback to nginx user (RHEL/CentOS)
                            uid = pwd.getpwnam('nginx').pw_uid
                            gid = grp.getgrnam('nginx').gr_gid
                        os.chown(str(cache_path), uid, gid)
                    except Exception:
                        pass  # Running as non-root or user doesn't exist
                except Exception as e:
                    logger.warning("Failed to create cache dir %s: %s", cache_path, e)

        # Backup existing config before overwriting
        backup_path = self.backup_config()
        
        # Write to file
        self.nginx_config_path.parent.mkdir(parents=True, exist_ok=True)
        self.nginx_config_path.write_text(nginx_config)

        # Reload Nginx
        if self.reload_nginx():
            self.current_version = version
            logger.info("Config updated to version %s", self.current_version)
            # Remove backup on success
            if backup_path:
                try:
                    Path(backup_path).unlink()
                except Exception:
                    pass
        else:
            logger.error("Failed to reload Nginx with new config")
            # Restore from backup
            if backup_path:
                if self.restore_config(backup_path):
                    # Try reloading with old config
                    self.reload_nginx()
                    logger.info("Restored previous config after failure")
            else:
                logger.error("No backup available to restore")

    async def run(self):
        """Main loop"""
        logger.info("Edge Config Updater started (node_id=%s, interval=%ss)", self.node_id, self.update_interval)
        
        # Start log shipper in background
        log_shipper = LogShipper(self.config, self.api_key)
        asyncio.create_task(log_shipper.run())

        while True:
            try:
                # Send heartbeat
                await self.send_heartbeat()
                
                # Update config
                await self.update_config()
            except Exception as e:
                logger.error("Error in update loop: %s", e, exc_info=True)

            await asyncio.sleep(self.update_interval)


def validate_config(config: Dict[str, Any]) -> bool:
    """Validate edge node configuration"""
    required_sections = ['edge_node', 'control_plane', 'nginx']
    
    for section in required_sections:
        if section not in config:
            logger.error("Missing required config section: %s", section)
            return False
    
    # Validate edge_node
    if 'id' not in config['edge_node']:
        logger.error("Missing edge_node.id in config")
        return False
    
    # Validate control_plane
    if 'url' not in config['control_plane']:
        logger.error("Missing control_plane.url in config")
        return False
    if 'api_key' not in config['control_plane']:
        logger.error("Missing control_plane.api_key in config")
        return False
    if config['control_plane']['api_key'] == 'your-api-key-here':
        logger.error("control_plane.api_key contains placeholder value")
        return False
    
    # Validate nginx
    if 'config_path' not in config['nginx']:
        logger.error("Missing nginx.config_path in config")
        return False
    if 'reload_command' not in config['nginx']:
        logger.error("Missing nginx.reload_command in config")
        return False
    
    return True


async def main():
    """Main entry point"""
    logger.info("Starting Edge Config Updater...")
    
    # Find config file
    config_path = os.getenv("EDGE_UPDATER_CONFIG", "config.yaml")
    config_file = Path(config_path)
    if not config_file.is_absolute():
        config_file = Path(__file__).resolve().parent / config_file
    
    # Check config file exists
    if not config_file.exists():
        logger.error("Config file not found: %s", config_file)
        logger.error("Please create config.yaml from config.example.yaml")
        return
    
    # Load and validate config
    with open(config_file) as f:
        config = yaml.safe_load(f)
    
    if not validate_config(config):
        logger.error("Config validation failed. Please check your config.yaml")
        return
    
    logger.info("Config loaded from %s", config_file)
    
    # Check nginx is available
    try:
        result = subprocess.run(['nginx', '-t'], capture_output=True, text=True)
        if result.returncode != 0:
            logger.warning("Nginx config test failed: %s", result.stderr)
            logger.warning("Agent will continue, but nginx might not reload properly")
    except FileNotFoundError:
        logger.error("nginx command not found. Please install nginx first.")
        return
    
    updater = EdgeConfigUpdater(str(config_file))
    await updater.run()


if __name__ == "__main__":
    asyncio.run(main())
